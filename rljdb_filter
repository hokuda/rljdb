#!/usr/bin/python3 -u
#!/usr/bin/pudb3
"""
DONE:
* set sourcepath
* debug log
* command name completion
* local variable name completion
* method completion
* field completion
* set breakpoint at startup
* class name completion
* acronyms
* release breakpoints during completion
* enahnced clear command
* enter-key to do last command
* v command to view source file
* conditional breakpoint


TODO:
- hit count
- stop command with condition
"""

import sys
import os
import re
import datetime
import time
import subprocess
import tempfile

if 'RLWRAP_FILTERDIR' in os.environ:
    sys.path.append(os.environ['RLWRAP_FILTERDIR'])
else:
    sys.path.append('.')

import rlwrapfilter
        
BREAKPOINT_FILE='./rljdb.breakpoint'
SOURCEPATH_FILE='./rljdb.sourcepath'
DEBUGLOG_FILE = './rljdb.debug'
DEBUGLOG = open(DEBUGLOG_FILE, mode='at') # append in text mode
DEBUG = True
#PROMPT = r"[>\]] " # default prompt pattern
PROMPT = r"^(>)|(.+\[[0-9]+\])\s" # default prompt pattern
COMMANDS = [
    # standard jdb commands
    'connectors',
    'run',
    'threads',
    'thread',
    'suspend',
    'resume',
    'where',
    'wherei',
    'up',
    'down',
    'kill',
    'interrupt',
    'print',
    'dump',
    'eval',
    'set',
    'locals',
    'classes',
    'class',
    'methods',
    'fields',
    'threadgroups',
    'threadgroup',
    'stop', # "stop in" and "stop at" are abolished
    'clear',
    'catch',
    'ignore',
    'watch',
    'unwatch',
    'trace',
    'untrace',
    'step',
    'stepi',
    'next',
    'cont',
    'list',
    'use',
    'exclude',
    'classpath',
    'monitor',
    'unmonitor',
    'read',
    'lock',
    'threadlocks',
    'pop',
    'reenter',
    'redefine',
    'disablegc',
    'enablegc',
    '!!',
    'help',
    'version',
    'exit',
    'quit',
    'v', # view source code
    # acronyms and custom commands
    's', # step
    'c', # cont
    'p', # print
    'n', # next
    'w', # where
    'd', # dump
    'l', # list
    'b', # break(stop)
    ]

ACRONYMS = {
    's':'step',
    'c':'cont',
    'p':'print',
    'n':'next',
    'w':'where',
    'd':'dump',
    'l':'list',
    'b':'break(stop)'
    }

rlwrap_filter = rlwrapfilter.RlwrapFilter()

class Singleton:
    """
    singleton decorator
    """
    def __init__(self,klass):
        self.klass = klass
        self.instance = None
    def __call__(self,*args,**kwds):
        if self.instance == None:
            self.instance = self.klass(*args,**kwds)
        self.instance.next = None
        return self.instance


class CompletionRequest:
    """
    request for completion
    """
    
    def __init__(self, line, prefix, completions):
        debug('CompletionRequest.__init__: line=' + line)
        debug('CompletionRequest.__init__: prefix=' + prefix)
        debug('CompletionRequest.__init__: completions=[' + ', '.join(completions) + ']')
        self.line = line
        self.prefix = prefix
        self.completions = completions
        self.tokens = get_tokens(line)
        debug('CompletionRequest.__init__: tokens=[' + ', '.join(self.tokens) + ']')
        debug('CompletionRequest.__init__: len(tokens)=' + str(len(self.tokens)))

        
class ExecutorBase:
    """
    base class for functions
    """

    def __init__(self):
        self.next = None

    def set_next(self, next):
        self.next = next
        return next

    def handle_completion(self, request):
        raise NotImplementedError()
        
    def completion_handler(self, request):
        request = self.handle_completion(request)
        if len(request.completions) == 1 and self.next != None: # req.completions==['']
            request = self.next.completion_handler(request)
        return request

    def handle_input(self, input_tokens):
        raise NotImplementedError()
        
    def input_handler(self, input_tokens):
        input_tokens = self.handle_input(input_tokens)
        if self.next != None:
            input_tokens = self.next.input_handler(input_tokens)
        return input_tokens

    def handle_output(self, output):
        raise NotImplementedError()
        
    def output_handler(self, output):
        output = self.handle_output(output)
        if self.next != None:
            output = self.next.output_handler(output)
        return output

    def handle_prompt(self, prompt):
        raise NotImplementedError()
        
    def prompt_handler(self, prompt):
        prompt = self.handle_prompt(prompt)
        if self.next != None:
            prompt = self.next.prompt_handler(prompt)
        return prompt

    

class CommandNameCompletionExecutor(ExecutorBase):
    def handle_completion(self, request):
        if len(request.tokens) != 1:
            return request
        pattern = r'^' + request.prefix
        completions = list(filter((lambda s: re.search(pattern, s)), COMMANDS))
        request.completions.extend(completions)
        return request

    
class LocalsCompletionExecutor(ExecutorBase):
    def handle_completion(self, request):
        if request.tokens[-1] != request.prefix:
            return request
        debug("Locals.handle_completion: " + request.tokens[0])
        if not request.tokens[0] in ['print', 'dump', 'p']:
            return request
        output = rlwrap_filter.cloak_and_dagger("locals", PROMPT, 1)
        locals = self.grep_by_prefix(request.prefix, self.parse_locals(output))
        if len(locals) == 1:
            locals.append(locals[0] + ".") # add "var." to completion list
        request.completions.extend(locals)
        return request


    def parse_locals(self, result):
        vars = list(
            filter(
                (lambda v: v != None),
                map(self.extract_varname, result.split('\n'))
            ))
        return vars

    def extract_varname(self, line):
        m = re.search(r"(.*) = .*", line)
        if m == None:
            return None
        else:
            return m.group(1)

    def grep_by_prefix(self, prefix, vars):
        return list(filter((lambda v: re.search(r"^" + prefix, v)), vars))


class ClassMemberCompletionExecutor(ExecutorBase):
    """
    complete names of fields and methods
    """
    def handle_completion(self, request):
        if not request.tokens[0] in ['print', 'dump', 'p', 'eval', 'set', 'stop', 'b', 'class', 'clear', 'watch', 'unwatch']:
            return request
        debug("ClassMemberCompletionExecutor.handle_completion: request.completions=[" + ",".join(request.completions))
        last_token = request.tokens[-1]
        if not '.' in last_token:
            return request
        [base_name, tail, paren] = self.parse_last_token(last_token)
        debug("ClassMemberCompetionExecutor.do_complition: base_name={0} tail={1} paren={2}".format(base_name, tail, paren))
        class_name = base_name if self.is_class_name(base_name) else self.get_class_name(base_name)
        if class_name == None:
            return request
        debug("ClassMemberCompetionExecutor.do_complition: class_name=" + class_name)
        if class_name != None:
            if paren == "":
                fields = self.complete_fields(class_name, tail)
                debug("ClassMemberCompletionExecutor.handle_completion: fields=[" + ",".join(fields))
                request.completions.extend(fields)
            methods = self.complete_methods(class_name, tail, paren)
            request.completions.extend(methods)
            # add "var." to completion list
            debug("ClassMemberCompletionExecutor.handle_completion: len(request.completions)=" + str(len(request.completions)))
            if len(request.completions)==1:
                request.completions.append(request.completions[0] + ".")
        return request

    def parse_last_token(self, last_token):
        """
        decompose token to fqdn, method, and parenses
        (example)
        when $last_token = "org.apache.catalina.connector.CoyoteAdapter.service(org.apache.",
        prior     = "org.apache.catalina.connector.CoyoteAdapter" and 
        posterior = "service"
        paren     = "(org.apache."
        """
        m = re.match(r"(.+)\.([^\.\(]+)(\([^\)]*)$", last_token)
        if m != None:
            debug("ClassMemberCompletionExecutor.parse_last_token: " +
                  "| {0} | {1} | {2} |".format(m.group(1), m.group(2), m.group(3)))
            return [m.group(1), m.group(2), m.group(3)]

        m = re.match(r"(.+)\.([^\.\(]+)$", last_token)
        if m != None:
            debug("ClassMemberCompletionExecutor.parse_last_token: " +
                  "| {0} | {1} |".format(m.group(1), m.group(2)))
            return [m.group(1), m.group(2), ""]

        m = re.match(r"(.+)\.$", last_token)
        if m != None:
            debug("ClassMemberCompletionExecutor.parse_last_token: " +
                  "| {0} |".format(m.group(1)))
            return [m.group(1), "", ""]

        return ["", "", ""] # finally
        
    def is_class_name(self, name):
        """
        returns true if `class $name` returns a valid class name.
        """
        command = "class {0}".format(name)
        output = rlwrap_filter.cloak_and_dagger(command, PROMPT, 10)
        debug("is_class_name: output={0}".format(output))
        m = re.match(r"Class: .*", output)
        return m != None
        
    def get_class_name(self, name):
        """
        returns $name.getClass()
        if $name.getClass() has an invalid value, returns None
        """
        output = rlwrap_filter.cloak_and_dagger("print {0}.getClass()".format(name), PROMPT, 1)
        debug("get_class_name : output = {0}".format(output))
        # example:
        # http-/127.0.0.1:8080-1[1] print res.commited.getClass()
        # com.sun.tools.example.debug.expr.ParseException: Cannot access field of primitive type: false
        #  res.commited.getClass() = null
        # http-/127.0.0.1:8080-1[1] print res.getClass()
        #  res.getClass() = "class org.apache.coyote.Response"
        m = re.match(r".+ = \"class (.+)\"", output)
        class_name = m.group(1) if m != None else None
        debug("get_class_name : class_name = {0}".format(class_name))
        return class_name

    def complete_fields(self, class_name, tail):
        debug("ClassMemberCompletionExecutor.complete_fields: tail=" + tail)
        output = rlwrap_filter.cloak_and_dagger("fields {0}".format(class_name), PROMPT, 1)
        debug("ClassMemberCompletionExecutor.complete_fields: output=" + output)
        fields = self.parse_fields(output)
        debug("ClassMemberCompletionExecutor.complete_fields: fields=[" + ",".join(fields))
        return list(filter((lambda x: re.search(r"^" + tail , x)), fields))
    

    def parse_fields(self, output):
        lines = output.split("\r\n")
        lines = lines[1:] # remove first
        debug("ClassMemberCompletionExecutor.parse_fields: lines = " + ",".join(lines))
        fields = list(
            map(
                (lambda m: m.group(2)),
                filter(
                    (lambda m: m != None),
                    map((lambda l: re.match(r"([^\s]+)\s([^\s]+)", l)), lines)
                )
            )
        )
        return fields

    def complete_methods(self, class_name, tail, paren):
        debug("ClassMemberCompletionExecutor.complete_methods: tail=" + tail)
        output = rlwrap_filter.cloak_and_dagger("methods {0}".format(class_name), PROMPT, 1)
        debug("ClassMemberCompletionExecutor.complete_methods: output=" + output)
        methods = self.parse_methods(output)
        debug("ClassMemberCompletionExecutor.complete_methods: methods=[" + ",".join(methods))
        return list(filter((lambda x: re.search(r"^" + tail , x)), methods))
    

    def parse_methods(self, output):
        lines = output.split("\r\n")
        lines = lines[1:] # remove first
        debug("ClassMemberCompletionExecutor.parse_methods: lines = " + ",".join(lines))
        methods = list(
            map(
                (lambda m: m.group(2)),
                filter(
                    (lambda m: m != None),
                    map((lambda l: re.match(r"([^\s]+)\s([^\s]+)", l)), lines)
                )
            )
        )
        return methods


class ClassNameCompletionExecutor(ExecutorBase):

    def escape_dots(self, string):
        """
        escape dots
        """
        return string.replace('.', '\\.')


    """
    complete FQCN
    """
    def handle_completion(self, request):
        if not request.tokens[0] in ['print', 'dump', 'p', 'stop', 'b', 'class', 'clear', 'watch', 'unwatch']:
            return request
        prefix = request.tokens[-1]
        escape_dots_prefix = self.escape_dots(prefix)
        rlwrapfilter.set_stoptext_search_area(-256, None)
        output = rlwrap_filter.cloak_and_dagger("classes", PROMPT, 5)
        classes = re.split(r"\s+", output)
        classes = list(filter((lambda v: re.search(r"^" + escape_dots_prefix, v)), classes))

        ind = prefix.rfind(".")
        if ind == -1: # not found '.'
            components = map((lambda x: re.match(r"^(" + prefix + ".*)", x).group(1)), classes)
        else:
            pkg = prefix[:ind]
            components = map((lambda x: re.match(r"^" + pkg + r"\.([^\.]+).*", x).group(1)), classes)
    
        components   = list(set(components)) # dedup

        if len(components) == 1: # add "var." to completion list
            components.append(components[0] + ".")

        request.completions.extend(components)
        return request


class ExpandAcronymExecutor(ExecutorBase):
    """
    replace an acronym to a long form
    """
    def handle_input(self, input_tokens):
        for (index, token) in enumerate(input_tokens):
            if len(token) == 0:
                continue
            if len(token) > 1:
                return input_tokens
            try:
                long_form = ACRONYMS[token]
            except KeyError:
                return input_tokens
            input_tokens[index] = long_form
            return input_tokens
        return input_tokens


@Singleton
class EnhancedClearCommandExecutor(ExecutorBase):
    """
    `clear` or `stop` command shows # and breakpoints
    `clear #` removes #th breakpoint
    """
    def __init__(self):
        super().__init__()
        self.index_out_of_bound = False
        self.clear_command_invoked = False


    def handle_input(self, input_tokens):
        """
        Removes #th break point
        """
        if input_tokens[0] == 'clear':
            self.clear_command_invoked = True
            if len(input_tokens) == 1: # 'clear' with no arg
                return(input_tokens)
            try:
                index = int(input_tokens[1])
                manager = BreakPointManager()
                size = len(manager.get_breakpoints())
                if index > size-1:
                    #rlwrap_filter.send_output_oob('index out of bound\n')
                    self.index_out_of_bound = True
                    return input_tokens
                b = manager.get_breakpoint(index)
                manager.remove(index)
                return ['clear', b.location]
            except ValueError:
                pass
        return input_tokens


    def handle_output(self, output):
        """
        Eats output if output =~ /^Breakpoints set:.*/ or self.index_out_of_bound == True
        """
        debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": output = " + output)
        if re.search(r"Breakpoints set:", output) or self.index_out_of_bound ==True:
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": ho------------- = " + output)
            return ""
        return output
    
    
    def handle_prompt(self, prompt):
        """
        Fetches cumulative_output if output =~ /^Breakpoints set:.*/, 
        modify it, 
        and put it to console
        """
        output = rlwrap_filter.cumulative_output
        debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": output = " + output)
        if self.index_out_of_bound == True:
            rlwrap_filter.send_output_oob('index out of bound\n')
        if self.clear_command_invoked == True:
            rlwrap_filter.send_output_oob('Breakpoints set:\n')
            self.print_breakpoints()
        self.index_out_of_bound = False
        self.clear_command_invoked = False
        return prompt


    def print_breakpoints(self):
        manager = BreakPointManager()
        break_points = manager.get_breakpoints()
        for i,b in enumerate(break_points):
            if b.condition:
                s = "    {:>2d} {:s} if {:s}".format(i, b.location, b.condition)
            else:
                s = "    {:>2d} {:s}".format(i, b.location)
            rlwrap_filter.send_output_oob(s + '\n')

    

@Singleton
class RepeatLastCommandExecutor(ExecutorBase):
    """
    Pressing enter key without typing a command do the last command to step
    """
    def __init__(self):
        super().__init__()
        self.last_command = None


    def handle_input(self, input_tokens):
        """
        Remembers the input_tokens, returns last_command when input_tokens is empty
        """
        if input_tokens[0] == '' and self.last_command[0] in ['s', 'c', 'n', 'step', 'cont', 'next']:
            input_tokens = self.last_command
        else:
            self.last_command = input_tokens
        return input_tokens


@Singleton
class ViewFileCommandExecutor(ExecutorBase):
    """
    emacsclient -n -e '(find-file-read-only "~/.emacs")' -e '(goto-line 40)'
    """
    def __init__(self):
        pass

    def handle_input(self, input_tokens):
        """
        invoke emacsclient to view self.classname at self.linenum
        """
        if len(input_tokens) == 1 and input_tokens[0] == 'v':
            basename = self.get_basename(self.class_method)
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": basename = " + basename)
            manager = SourcePathManager()
            first = self.find(manager.source_path, basename + '.java').__next__()
            command = "emacsclient -n -e '(find-file-read-only \"" + first + "\")' -e '(goto-line " + str(self.linenum) + ")'"
            os.system(command)
            return input_tokens
        # else
        return input_tokens

    def get_basename(self, class_method):
        return class_method.split('.')[-2]

    def handle_prompt(self, prompt):
        """
        Fetches cumulative_output if output =~ /^Breakpoint hit:.*/, 
        parses it, and register classname and line number
        """
        output = rlwrap_filter.cumulative_output
        debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": output = " + output)
        m = re.search(r"Breakpoint hit: \"thread=.*\", (.*), line=([0-9]*) bci=.*", output)
        if m:
            self.class_method = m.group(1)
            self.linenum = m.group(2)
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name
                  + ": class_method = " + self.class_method
                  + ": linenum = " + self.linenum
            )
        return prompt

    def find(self, sourcepath, filename):
        debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name
              + ": sourcepath = " + ','.join(sourcepath)
              + ": filename = " + filename
        )
        pattern = re.compile(re.escape(filename) + '$')
        for directory in sourcepath:
            for root, dirs, files in os.walk(directory):
                for file in files:
                    debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name
                          + ": root = " + root
                          + ": file = |" + file + "|"
                    )
                    if pattern.search(file) == None:
                        continue
                    yield os.path.join(root, file)


class ConditionalBreakpointExecutor(ExecutorBase):
    """
    Catches "Breakpoint hit: "thread=...", package.ClassName.method(), line=MM bci=NN",
    repeat "cont" and "print <condition>" until <condition> is true.
    Supports only 'stop at' command but not 'stop in' command
    """
    def __init__(self):
        super().__init__()

    def handle_prompt(self, prompt):
        """
        Fetches cumulative_output if output =~ /^Breakpoint hit:.*/, 
        parses it, and register classname and line number
        """
        output = rlwrap_filter.cumulative_output
        while(True):
            location = self.get_breakpoint_location_at_line(output)
            if location == None:
                return prompt
            condition = self.get_condition(location)
            if condition == None:
                return prompt
            if self.is_condition_true(condition):
                return prompt
            output = self.do_continue()
            lines = output.split('\r\n')
            output_wo_prompt = '\n'.join(lines[0:-2])
            # output を表示
            rlwrap_filter.send_output_oob(output_wo_prompt + '\n\n')
        return prompt

    def do_continue(self):
        return rlwrap_filter.cloak_and_dagger('cont', PROMPT, 0.1)
        
    def get_condition(self, location):
        manager = BreakPointManager()
        for b in manager.get_breakpoints():
            if b.location == location:
                return b.condition
        return None

    def is_condition_true(self, condition):
        output = rlwrap_filter.cloak_and_dagger('print ' + condition, PROMPT, 0.1)
        result = self.parse_output(output)
        # condition 評価結果を表示
        if result:
            rlwrap_filter.send_output_oob('Conditional breakpoint hit since: '
                                          + output.split('\r\n')[0]
                                          + '\n')
        else:
            rlwrap_filter.send_output_oob('Conditional breakpoint skipped since: '
                                          + '\n'.join(output.split('\r\n')[0:-1])
                                          + '\n')
        return result

    def parse_output(self, output):
        tokens = output.split('\r\n')[0].split(' ')
        debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": tokens = " + ','.join(tokens))
        return tokens[-1] == 'true'
    
    def get_breakpoint_location_at_line(self, output):
        debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": output = " + output)
        m = re.search(r"Breakpoint hit: \"thread=.*\", (.*), line=([0-9]*) bci=.*", output)
        if m:
            class_method = m.group(1)
            linenum = m.group(2)
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name
                  + ": class_method = " + class_method
                  + ": linenum = " + linenum
            )
            class_name = re.match(r'(.+)\.[^\.]+\(.*\)', class_method).group(1)
            return class_name + ':' + linenum
        return None


class BreakPoint:
    """
    break point
    """
    def __init__(self, location, condition=None, hit_count=None):
        self.location = location
        self.condition = condition
        self.hit_count = hit_count


@Singleton
class BreakPointManager:
    def __init__(self):
        self.break_points = []

    def get_breakpoints(self):
        return self.break_points
    
    def add(self, break_point):
        self.break_points.append(break_point)

    def get_breakpoint(self, i):
        return self.break_points[i]
        
    def remove(self, i):
        del self.break_points[i]

    def get(self, index):
        pass

    def activate(self):
        for b in self.break_points:
            if re.match(r".*:.*", b.location):
                output = rlwrap_filter.cloak_and_dagger("stop at " + b.location, PROMPT, 0.1)
            else:
                output = rlwrap_filter.cloak_and_dagger("stop in " + b.location, PROMPT, 0.1)
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": output = " + output)
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": location = " + b.location)
            debug(self.__class__.__name__ + "." + sys._getframe().f_code.co_name + ": output = " + output.replace('\r\n','\\r\\n'))
            if b.location in output.replace('\r\n', '\\r\\n'):
                continue
            #vacuum_until_match(re.escape(b.location))


    def deactivate(self):
        result = rlwrap_filter.cloak_and_dagger("clear", PROMPT, 0.1)
        break_points = self.parse_clear(result)
        debug("BreakPointerManager.deactivate: bread points=[" + ",".join(break_points) + "]")
        for b in break_points:
            output = rlwrap_filter.cloak_and_dagger("clear " + b, PROMPT, 0.1)
            debug("BreakPointerManager.deactivate: clear for each bp output=" + output)
            if b in output.replace('\r\n', '\\r\\n'):
                continue
            #vacuum_until_match(re.escape(b))


    def parse_clear(self, result):
        lines = result.split('\r\n')
        lines.reverse()
        lines.pop() # remove first line
        vars = list(
            filter(
                (lambda x: x!=None),
                map(self.extract_breakpoint, lines)
                )
            )
        debug("BreakPointerManager.parse_clear: vars=" + ",".join(vars))
        return vars

    def extract_breakpoint(self, line):
        debug("BreakPointerManager.extract_breakpoint: line=" + line)
        m = re.search(r".*breakpoint (.*)", line)
        if m == None:
            debug("BreakPointerManager.extract_breakpoint: m.group(1)=None")
            return None
        else:
            debug("BreakPointerManager.extract_breakpoint: m.group(1)=" + m.group(1))
            return m.group(1)


def set_breakpoint():
    try:
        with open(BREAKPOINT_FILE, "rt") as file:
            rlwrap_filter.send_output_oob("Found "+ BREAKPOINT_FILE + "\n")
            manager = BreakPointManager()
            for line in file:
                line = line.strip() # remove \n at the end of the line
                m = re.match(r'(.+)\s+if\s+(.+)', line)
                if m:
                    location = m.group(1)
                    condition = m.group(2)
                else:
                    location = line
                    condition = None
                if '#' in location:
                    continue
                bp = BreakPoint(location, condition=condition)
                manager.add(bp)
            manager.activate()
    except:
        debug('Could not open ' + BREAKPOINT_FILE)


def vacuum_until_match(substring):
    debug("vacuum_until_match: substring = " + substring)
    while(True):
        output = rlwrap_filter.vacuum_stale_message(substring, 1.0)
        debug("vacuum_until_match: output = " + output)
        if substring in output:
            return


@Singleton
class SourcePathManager:
    def __init__(self):
        self.source_path = []


def set_sourcepath():
    sourcepath = '' # list of paths delimited by ':'
    manager = SourcePathManager()
    try:
        with open(SOURCEPATH_FILE, "rt") as file:
            rlwrap_filter.send_output_oob("Found " + SOURCEPATH_FILE + '\n')
            for path in file:
                path = path.rstrip() # remove \n at the end of the line
                manager.source_path.append(path)
                if re.match(r'^\s*#.*', path):
                    continue
                sourcepath += path + ':'
    except:
        debug('Could not open ' + SOURCEPATH_FILE)

    output = rlwrap_filter.cloak_and_dagger("use " + sourcepath, "> ", 1);

        
def debug(msg):
    if DEBUG:
        now = datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")
        DEBUGLOG.write(now)
        DEBUGLOG.write(" ")
        DEBUGLOG.write(msg)
        DEBUGLOG.write('\n')
        DEBUGLOG.flush()


def info(msg):
    rlwrap_filter.send_output_oob(msg)
    rlwrap_filter.send_output_oob('\n')


def initialize():
    def do_nothing():
        pass
    global initialize
    set_breakpoint()
    set_sourcepath()

    # clean up stale output which arrives late
    #time.sleep(1)
    #rlwrap_filter.discharge_scum(PROMPT, 1.0)

    initialize = do_nothing # run once


def prompt_handler(prompt):
    """
    prompt handler
    """
    if len(prompt)==0:
        #return "> "
        return ""
    else:
        initialize()
        debug("prompt_handler: prompt=|" + prompt + "|")
        #return prompt
    executor = EnhancedClearCommandExecutor()
    executor.set_next(
        ViewFileCommandExecutor()
    ).set_next(
        ConditionalBreakpointExecutor()
    )
    prompt = executor.prompt_handler(prompt)
    return prompt


def completion_handler(line, prefix, completions):
    """
    completion handler
    """
    executor = CommandNameCompletionExecutor()
    executor.set_next(
        LocalsCompletionExecutor()
    ).set_next(
        ClassMemberCompletionExecutor()
    ).set_next(
        ClassNameCompletionExecutor()
    )
    BreakPointManager().deactivate()
    request = executor.completion_handler(CompletionRequest(line, prefix, completions))
    BreakPointManager().activate()
    return request.completions


def input_handler(input):
    """
    input handler
    """
    executor = ExpandAcronymExecutor()
    executor.set_next(
        EnhancedClearCommandExecutor()
    ).set_next(
        RepeatLastCommandExecutor()
    ).set_next(
        ViewFileCommandExecutor()
    )
    input_tokens = input.split(' ')
    input_tokens = executor.input_handler(input_tokens)
    #debug(input_tokens)
    input = ' '.join(input_tokens)
    return input


def output_handler(output):
    """
    output handler
    """
    executor = EnhancedClearCommandExecutor()
    output = executor.output_handler(output)
    return output


def get_tokens(line):
    """
    returns the tokens + '' if line ends with " "(white space)
    retruns the tokens otherwise
    """
    tokens = re.split(r'\s', line.lstrip(' '))
    debug('get_tokes: ["' + '", "'.join(tokens) + '"]')
    return tokens


def logit(message, tag):
    """
    a message_handler is seldom used (as it cannot change messages, only examine them) 
    It gets called with the tag as its second argument
    """
    tagname = rlwrap_filter.tag2name(tag)
    tagname = re.sub(r'^TAG_', '', tagname)
    mangled = message
    mangled = re.sub(r'\n', r'\\n', mangled)
    mangled = re.sub(r'\r', r'\\r', mangled)
    mangled = re.sub(r'\t', r'\\t', mangled)
    mangled = re.sub(r'\x1b', r'\\e', mangled)
    debug("logit: {0:10s} '{1}'".format(tagname, mangled))
    return message

    
if __name__ == '__main__':

    debug('rljdb gets started\n')

    rlwrap_filter.cloak_and_dagger_verbose = False
    #rlwrap_filter.cloak_and_dagger_verbose = True
    rlwrap_filter.prompt_handler = prompt_handler
    rlwrap_filter.completion_handler = completion_handler
    rlwrap_filter.input_handler = input_handler
    rlwrap_filter.output_handler = output_handler
    rlwrap_filter.message_handler=logit

    rlwrap_filter.run()
